import { execSync } from "child_process";
import { writeFileSync, existsSync, readFileSync, mkdirSync } from "fs";
import { join, dirname } from "path";
import { fileURLToPath } from "url";

// Get repo root
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const REPO_ROOT = join(__dirname, "..");
const TRACES_DIR = join(REPO_ROOT, "traces");

// Ensure traces directory exists
if (!existsSync(TRACES_DIR)) {
  mkdirSync(TRACES_DIR, { recursive: true });
}

interface TraceEntry {
  pc: number;
  op: number;
  opName?: string;
  gas: string;
  gasCost: string;
  stack: string[];
  depth: number;
  memory?: string[];
  storage?: Record<string, string>;
  returnData?: string;
}

interface TraceDivergence {
  step: number;
  ourTrace: TraceEntry;
  refTrace: TraceEntry;
  reason: string;
  details: string[];
}

class TraceComparator {
  private testName: string;
  private ourTracePath: string;
  private refTracePath: string;

  constructor(testName: string) {
    this.testName = testName;
    this.ourTracePath = join(TRACES_DIR, `${testName}_our.jsonl`);
    this.refTracePath = join(TRACES_DIR, `${testName}_ref.jsonl`);
  }

  // Run test and capture both traces
  async captureTraces(): Promise<boolean> {
    console.log(`\n${"=".repeat(80)}`);
    console.log(`üîç Capturing traces for: ${this.testName}`);
    console.log(`${"=".repeat(80)}\n`);

    try {
      // Run the test with our implementation
      console.log("üìù Running test with Guillotine implementation...");
      const ourOutput = execSync(
        `TEST_FILTER="${this.testName}" zig build specs`,
        {
          cwd: REPO_ROOT,
          encoding: "utf-8",
          stdio: "pipe",
          env: {
            ...process.env,
            TRACE_OUTPUT: this.ourTracePath,
          },
        },
      );

      console.log("‚úÖ Our trace captured");

      // Check if reference trace exists (generated by test runner)
      if (existsSync(this.refTracePath)) {
        console.log("‚úÖ Reference trace found");
        return true;
      } else {
        console.log("‚ö†Ô∏è  Reference trace not found at:", this.refTracePath);
        console.log(
          "The test runner should generate this automatically. Check test/specs/runner.zig",
        );
        return false;
      }
    } catch (error: any) {
      console.log("‚ùå Test execution failed (expected for failing tests)");
      // Even if test fails, traces might have been captured
      return existsSync(this.ourTracePath) && existsSync(this.refTracePath);
    }
  }

  // Parse JSONL trace file
  parseTrace(filePath: string): TraceEntry[] {
    if (!existsSync(filePath)) {
      console.error(`‚ùå Trace file not found: ${filePath}`);
      return [];
    }

    const content = readFileSync(filePath, "utf-8");
    const lines = content.trim().split("\n");
    const entries: TraceEntry[] = [];

    for (const line of lines) {
      if (!line.trim()) continue;
      try {
        const entry = JSON.parse(line);
        entries.push(entry);
      } catch (e) {
        console.warn(`‚ö†Ô∏è  Failed to parse trace line: ${line.slice(0, 100)}`);
      }
    }

    return entries;
  }

  // Find the exact divergence point
  findDivergence(
    ourTrace: TraceEntry[],
    refTrace: TraceEntry[],
  ): TraceDivergence | null {
    const maxSteps = Math.max(ourTrace.length, refTrace.length);

    for (let i = 0; i < maxSteps; i++) {
      const ours = ourTrace[i];
      const ref = refTrace[i];

      // Check if one trace ended early
      if (!ours) {
        return {
          step: i,
          ourTrace: { pc: -1, op: -1, gas: "0", gasCost: "0", stack: [], depth: 0 },
          refTrace: ref,
          reason: "Our trace ended early",
          details: [
            `Our trace has ${ourTrace.length} steps`,
            `Reference trace has ${refTrace.length} steps`,
          ],
        };
      }

      if (!ref) {
        return {
          step: i,
          ourTrace: ours,
          refTrace: { pc: -1, op: -1, gas: "0", gasCost: "0", stack: [], depth: 0 },
          reason: "Reference trace ended early",
          details: [
            `Our trace has ${ourTrace.length} steps`,
            `Reference trace has ${refTrace.length} steps`,
          ],
        };
      }

      // Check for PC divergence
      if (ours.pc !== ref.pc) {
        return {
          step: i,
          ourTrace: ours,
          refTrace: ref,
          reason: "Program counter (PC) divergence",
          details: [
            `Our PC: ${ours.pc}`,
            `Reference PC: ${ref.pc}`,
            `Difference: ${ours.pc - ref.pc}`,
          ],
        };
      }

      // Check for opcode divergence
      if (ours.op !== ref.op) {
        return {
          step: i,
          ourTrace: ours,
          refTrace: ref,
          reason: "Opcode divergence",
          details: [
            `Our opcode: 0x${ours.op.toString(16).padStart(2, "0")} (${ours.opName || "unknown"})`,
            `Reference opcode: 0x${ref.op.toString(16).padStart(2, "0")} (${ref.opName || "unknown"})`,
          ],
        };
      }

      // Check for gas divergence
      if (ours.gas !== ref.gas) {
        const ourGas = BigInt(ours.gas);
        const refGas = BigInt(ref.gas);
        const diff = ourGas - refGas;

        return {
          step: i,
          ourTrace: ours,
          refTrace: ref,
          reason: "Gas remaining divergence",
          details: [
            `Our gas: ${ours.gas}`,
            `Reference gas: ${ref.gas}`,
            `Difference: ${diff > 0 ? "+" : ""}${diff} (we have ${diff > 0 ? "more" : "less"} gas)`,
            `Opcode: 0x${ours.op.toString(16).padStart(2, "0")} (${ours.opName || "unknown"})`,
          ],
        };
      }

      // Check for stack divergence
      if (JSON.stringify(ours.stack) !== JSON.stringify(ref.stack)) {
        const details = [`Stack depth: ours=${ours.stack.length}, ref=${ref.stack.length}`];

        // Show top 5 stack items
        const showCount = Math.min(5, Math.max(ours.stack.length, ref.stack.length));
        for (let j = 0; j < showCount; j++) {
          const ourVal = ours.stack[ours.stack.length - 1 - j] || "(empty)";
          const refVal = ref.stack[ref.stack.length - 1 - j] || "(empty)";
          if (ourVal !== refVal) {
            details.push(`  Stack[${j}]: ours=${ourVal.slice(0, 20)}..., ref=${refVal.slice(0, 20)}...`);
          }
        }

        return {
          step: i,
          ourTrace: ours,
          refTrace: ref,
          reason: "Stack state divergence",
          details,
        };
      }

      // Check for depth divergence
      if (ours.depth !== ref.depth) {
        return {
          step: i,
          ourTrace: ours,
          refTrace: ref,
          reason: "Call depth divergence",
          details: [
            `Our depth: ${ours.depth}`,
            `Reference depth: ${ref.depth}`,
          ],
        };
      }
    }

    return null; // No divergence found
  }

  // Format trace entry for display
  formatTraceEntry(entry: TraceEntry, label: string): string[] {
    const lines: string[] = [];
    lines.push(`${label}:`);
    lines.push(`  PC: ${entry.pc}`);
    lines.push(
      `  Opcode: 0x${entry.op.toString(16).padStart(2, "0")} (${entry.opName || "unknown"})`,
    );
    lines.push(`  Gas: ${entry.gas}`);
    lines.push(`  Gas Cost: ${entry.gasCost}`);
    lines.push(`  Depth: ${entry.depth}`);

    if (entry.stack.length > 0) {
      lines.push(`  Stack (top 5):`);
      const showCount = Math.min(5, entry.stack.length);
      for (let i = 0; i < showCount; i++) {
        const val = entry.stack[entry.stack.length - 1 - i];
        lines.push(`    [${i}] ${val.slice(0, 66)}${val.length > 66 ? "..." : ""}`);
      }
    }

    if (entry.memory && entry.memory.length > 0) {
      lines.push(`  Memory: ${entry.memory.length} bytes`);
    }

    return lines;
  }

  // Display side-by-side comparison
  displayDivergence(divergence: TraceDivergence): void {
    console.log(`\n${"‚ñà".repeat(80)}`);
    console.log(`üö® TRACE DIVERGENCE DETECTED`);
    console.log(`${"‚ñà".repeat(80)}\n`);

    console.log(`Step: ${divergence.step}`);
    console.log(`Reason: ${divergence.reason}\n`);

    console.log("Details:");
    for (const detail of divergence.details) {
      console.log(`  ${detail}`);
    }

    console.log(`\n${"-".repeat(80)}`);
    console.log("SIDE-BY-SIDE COMPARISON");
    console.log(`${"-".repeat(80)}\n`);

    const ourLines = this.formatTraceEntry(divergence.ourTrace, "OUR IMPLEMENTATION");
    const refLines = this.formatTraceEntry(divergence.refTrace, "REFERENCE");

    const maxLines = Math.max(ourLines.length, refLines.length);

    for (let i = 0; i < maxLines; i++) {
      const ourLine = (ourLines[i] || "").padEnd(40);
      const refLine = refLines[i] || "";
      console.log(`${ourLine} ‚îÇ ${refLine}`);
    }

    console.log(`\n${"-".repeat(80)}`);
  }

  // Display context around divergence
  displayContext(
    ourTrace: TraceEntry[],
    refTrace: TraceEntry[],
    divergenceStep: number,
  ): void {
    console.log(`\n${"‚îÄ".repeat(80)}`);
    console.log("CONTEXT (5 steps before divergence)");
    console.log(`${"‚îÄ".repeat(80)}\n`);

    const startStep = Math.max(0, divergenceStep - 5);

    for (let i = startStep; i < divergenceStep; i++) {
      const ours = ourTrace[i];
      const ref = refTrace[i];

      if (!ours || !ref) continue;

      const marker = i === divergenceStep - 1 ? "‚Üí" : " ";
      console.log(
        `${marker} Step ${i}: PC=${ours.pc} Op=0x${ours.op.toString(16).padStart(2, "0")} Gas=${ours.gas}`,
      );
    }

    console.log(`\n${"‚îÄ".repeat(80)}`);
  }

  // Generate markdown report
  generateReport(divergence: TraceDivergence | null): string {
    let report = `# Trace Comparison Report\n\n`;
    report += `**Test**: ${this.testName}\n`;
    report += `**Generated**: ${new Date().toISOString()}\n\n`;

    if (!divergence) {
      report += `‚úÖ **No divergence found** - Traces match perfectly!\n\n`;
      report += `This could mean:\n`;
      report += `- The implementation is correct for this test\n`;
      report += `- The test might be failing for a different reason (final state check, gas total, etc.)\n`;
      return report;
    }

    report += `## üö® Divergence Summary\n\n`;
    report += `- **Step**: ${divergence.step}\n`;
    report += `- **Reason**: ${divergence.reason}\n\n`;

    report += `### Details\n\n`;
    for (const detail of divergence.details) {
      report += `- ${detail}\n`;
    }

    report += `\n## Our Implementation\n\n`;
    report += `\`\`\`\n`;
    report += this.formatTraceEntry(divergence.ourTrace, "Our trace").join("\n");
    report += `\n\`\`\`\n\n`;

    report += `## Reference Implementation\n\n`;
    report += `\`\`\`\n`;
    report += this.formatTraceEntry(divergence.refTrace, "Reference trace").join("\n");
    report += `\n\`\`\`\n\n`;

    report += `## What to do next\n\n`;
    report += `1. **Identify the diverging operation**:\n`;
    report += `   - Opcode: 0x${divergence.ourTrace.op.toString(16).padStart(2, "0")} (${divergence.ourTrace.opName || "unknown"})\n`;
    report += `   - Program counter: ${divergence.ourTrace.pc}\n\n`;

    report += `2. **Find the Python reference**:\n`;
    report += `   \`\`\`bash\n`;
    report += `   cd execution-specs/src/ethereum/forks/<hardfork>/vm/instructions/\n`;
    report += `   grep -r "def ${divergence.ourTrace.opName?.toLowerCase() || "unknown"}" .\n`;
    report += `   \`\`\`\n\n`;

    report += `3. **Compare implementations**:\n`;
    report += `   - Zig: \`src/frame.zig\` (search for opcode 0x${divergence.ourTrace.op.toString(16).padStart(2, "0")})\n`;
    report += `   - Python: Found in step 2\n\n`;

    report += `4. **Check for common issues**:\n`;
    if (divergence.reason.includes("gas")) {
      report += `   - Missing gas charges (memory expansion, cold access, etc.)\n`;
      report += `   - Wrong gas constants for this hardfork\n`;
      report += `   - Incorrect gas charge order\n`;
    } else if (divergence.reason.includes("stack")) {
      report += `   - Wrong stack operation order\n`;
      report += `   - Missing or extra stack pushes/pops\n`;
      report += `   - Incorrect arithmetic operation\n`;
    } else if (divergence.reason.includes("PC")) {
      report += `   - Wrong jump destination calculation\n`;
      report += `   - Missing PC increment\n`;
      report += `   - Incorrect opcode size handling\n`;
    }

    report += `\n## Traces\n\n`;
    report += `- Our trace: \`${this.ourTracePath}\`\n`;
    report += `- Reference trace: \`${this.refTracePath}\`\n`;

    return report;
  }

  async run(skipCapture: boolean = false): Promise<void> {
    // Step 1: Capture traces (unless skipped)
    if (!skipCapture) {
      const captured = await this.captureTraces();
      if (!captured) {
        console.error("‚ùå Failed to capture traces");
        process.exit(1);
      }
    }

    // Step 2: Parse traces
    console.log("\nüìñ Parsing traces...");
    const ourTrace = this.parseTrace(this.ourTracePath);
    const refTrace = this.parseTrace(this.refTracePath);

    console.log(`  Our trace: ${ourTrace.length} steps`);
    console.log(`  Reference trace: ${refTrace.length} steps`);

    if (ourTrace.length === 0 || refTrace.length === 0) {
      console.error("‚ùå One or both traces are empty");
      process.exit(1);
    }

    // Step 3: Find divergence
    console.log("\nüîç Analyzing divergence...");
    const divergence = this.findDivergence(ourTrace, refTrace);

    // Step 4: Display results
    if (!divergence) {
      console.log("\n‚úÖ No divergence found - traces match perfectly!");
      console.log(
        "The test failure might be due to final state checks, not execution trace.",
      );
    } else {
      this.displayDivergence(divergence);
      this.displayContext(ourTrace, refTrace, divergence.step);
    }

    // Step 5: Generate report
    const report = this.generateReport(divergence);
    const reportPath = join(TRACES_DIR, `${this.testName}_analysis.md`);
    writeFileSync(reportPath, report, "utf-8");

    console.log(`\nüìÑ Full report saved to: ${reportPath}`);
    console.log(`${"=".repeat(80)}\n`);

    // Exit with error code if divergence found
    if (divergence) {
      process.exit(1);
    }
  }
}

// CLI
async function main() {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    console.log(`
Trace Comparison Tool
=====================

Usage:
  bun run scripts/compare-traces.ts <test_name> [--skip-capture]

Description:
  Captures and compares execution traces between our implementation
  and the Python reference implementation, showing the EXACT point
  where behavior diverges.

Example:
  bun run scripts/compare-traces.ts transientStorageReset
  bun run scripts/compare-traces.ts push0_basic
  bun run scripts/compare-traces.ts test_gas_diff --skip-capture

Options:
  --skip-capture    Use existing trace files without running tests
                    (useful for testing the tool itself)

Output:
  - Console: Side-by-side comparison of divergence point
  - File: traces/<test_name>_analysis.md (detailed report)

Note:
  The test runner must be configured to output EIP-3155 traces.
  Check test/specs/runner.zig for trace output configuration.
    `);
    process.exit(1);
  }

  const testName = args[0];
  const skipCapture = args.includes("--skip-capture");
  const comparator = new TraceComparator(testName);
  await comparator.run(skipCapture);
}

main().catch(console.error);
